<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>你有必要知道的 25 个 JavaScript 面试题 | 刘伟坤个人博客 - 一个梦想成为web前端开发人员的个人博客网站</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1、使用 typeof bar === “object” 判断 bar 是不是一个对象有神马潜在的弊端？如何避免这种弊端？ 使用 typeof 的弊端是显而易见的(这种弊端同使用 instanceof)： let obj = {};let arr = []; console.log(typeof obj === ‘object’);  //trueconsole.log(typeof arr ==">
<meta property="og:type" content="article">
<meta property="og:title" content="你有必要知道的 25 个 JavaScript 面试题">
<meta property="og:url" content="http://yoursite.com/2015/05/05/你有必要知道的 25 个 JavaScript 面试题/index.html">
<meta property="og:site_name" content="刘伟坤个人博客 - 一个梦想成为web前端开发人员的个人博客网站">
<meta property="og:description" content="1、使用 typeof bar === “object” 判断 bar 是不是一个对象有神马潜在的弊端？如何避免这种弊端？ 使用 typeof 的弊端是显而易见的(这种弊端同使用 instanceof)： let obj = {};let arr = []; console.log(typeof obj === ‘object’);  //trueconsole.log(typeof arr ==">
<meta property="og:updated_time" content="2017-07-08T04:46:22.398Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="你有必要知道的 25 个 JavaScript 面试题">
<meta name="twitter:description" content="1、使用 typeof bar === “object” 判断 bar 是不是一个对象有神马潜在的弊端？如何避免这种弊端？ 使用 typeof 的弊端是显而易见的(这种弊端同使用 instanceof)： let obj = {};let arr = []; console.log(typeof obj === ‘object’);  //trueconsole.log(typeof arr ==">
  
    <link rel="alternative" href="/atom.xml" title="刘伟坤个人博客 - 一个梦想成为web前端开发人员的个人博客网站" type="application/atom+xml">
  
  
    <link rel="icon" href="http://www.sxit.club/img/lwk.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
  
  

  <script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>
  <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

  
</head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://www.sxit.club/img/lwk.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">刘伟坤</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.sxwl.pw">面试宝典</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">刘伟坤</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://www.sxit.club/img/lwk.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">刘伟坤</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-你有必要知道的 25 个 JavaScript 面试题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/05/你有必要知道的 25 个 JavaScript 面试题/" class="article-date">
  	<time datetime="2015-05-05T07:45:12.000Z" itemprop="datePublished">2015-05-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      你有必要知道的 25 个 JavaScript 面试题
      
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
        

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1、使用 typeof bar === “object” 判断 bar 是不是一个对象有神马潜在的弊端？如何避免这种弊端？</p>
<p>使用 typeof 的弊端是显而易见的(这种弊端同使用 instanceof)：</p>
<p>let obj = {};<br>let arr = [];</p>
<p>console.log(typeof obj === ‘object’);  //true<br>console.log(typeof arr === ‘object’);  //true<br>console.log(typeof null === ‘object’);  //true<br>从上面的输出结果可知，typeof bar === “object” 并不能准确判断 bar 就是一个 Object。可以通过Object.prototype.toString.call(bar) === “[object Object]” 来避免这种弊端：</p>
<p>let obj = {};<br>let arr = [];</p>
<p>console.log(Object.prototype.toString.call(obj));  //[object Object]<br>console.log(Object.prototype.toString.call(arr));  //[object Array]<br>console.log(Object.prototype.toString.call(null));  //[object Null]</p>
<p>而 [] === false 是返回 false 的。<br>2、下面的代码会在 console 输出神马？为什么？</p>
<p>(function(){<br>  var a = b = 3;<br>})();</p>
<p>console.log(“a defined? “ + (typeof a !== ‘undefined’));<br>console.log(“b defined? “ + (typeof b !== ‘undefined’));<br>这跟变量作用域有关，输出换成下面的：</p>
<p>console.log(b); //3<br>console,log(typeof a); //undefined<br>拆解一下自执行函数中的变量赋值：</p>
<p>b = 3;<br>var a = b;<br>所以 b 成了全局变量，而 a 是自执行函数的一个局部变量。</p>
<p>3、下面的代码会在 console 输出神马？为什么？</p>
<p>var myObject = {<br>    foo: “bar”,<br>    func: function() {<br>        var self = this;<br>        console.log(“outer func:  this.foo = “ + this.foo);<br>        console.log(“outer func:  self.foo = “ + self.foo);<br>        (function() {<br>            console.log(“inner func:  this.foo = “ + this.foo);<br>            console.log(“inner func:  self.foo = “ + self.foo);<br>        }());<br>    }<br>};<br>myObject.func();<br>第一个和第二个的输出不难判断，在 ES6 之前，JavaScript 只有函数作用域，所以 func 中的 IIFE 有自己的独立作用域，并且它能访问到外部作用域中的 self，所以第三个输出会报错，因为 this 在可访问到的作用域内是 undefined，第四个输出是 bar。如果你知道闭包，也很容易解决的：</p>
<p>(function(test) {<br>            console.log(“inner func:  this.foo = “ + test.foo);  //‘bar’<br>            console.log(“inner func:  self.foo = “ + self.foo);<br>}(self));<br>如果对闭包不熟悉，可以戳此：从作用域链谈闭包</p>
<p>4、将 JavaScript 代码包含在一个函数块中有神马意思呢？为什么要这么做？</p>
<p>换句话说，为什么要用立即执行函数表达式（Immediately-Invoked Function Expression）。</p>
<p>IIFE 有两个比较经典的使用场景，一是类似于在循环中定时输出数据项，二是类似于 JQuery/Node 的插件和模块开发。</p>
<p>for(var i = 0; i &lt; 5; i++) {<br>    setTimeout(function() {<br>        console.log(i);<br>    }, 1000);<br>}<br>上面的输出并不是你以为的0，1，2，3，4，而输出的全部是5，这时 IIFE 就能有用了：</p>
<p>for(var i = 0; i &lt; 5; i++) {<br>    (function(i) {<br>      setTimeout(function() {<br>        console.log(i);<br>      }, 1000);<br>    })(i)<br>}<br>而在 JQuery/Node 的插件和模块开发中，为避免变量污染，也是一个大大的 IIFE：</p>
<p>(function($) {<br>        //代码<br> } )(jQuery);<br>5、在严格模式(‘use strict’)下进行 JavaScript 开发有神马好处？</p>
<p>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;<br>消除代码运行的一些不安全之处，保证代码运行的安全；<br>提高编译器效率，增加运行速度；<br>为未来新版本的Javascript做好铺垫。<br>6、下面两个函数的返回值是一样的吗？为什么？</p>
<p>function foo1()<br>{<br>  return {<br>      bar: “hello”<br>  };<br>}</p>
<p>function foo2()<br>{<br>  return<br>  {<br>      bar: “hello”<br>  };<br>}<br>在编程语言中，基本都是使用分号（;）将语句分隔开，这可以增加代码的可读性和整洁性。而在JS中，如若语句各占独立一行，通常可以省略语句间的分号（;），JS 解析器会根据能否正常编译来决定是否自动填充分号：</p>
<p>var test = 1 +<br>2<br>console.log(test);  //3<br>在上述情况下，为了正确解析代码，就不会自动填充分号了，但是对于 return 、break、continue 等语句，如果后面紧跟换行，解析器一定会自动在后面填充分号(;)，所以上面的第二个函数就变成了这样：</p>
<p>function foo2()<br>{<br>  return;<br>  {<br>      bar: “hello”<br>  };<br>}<br>所以第二个函数是返回 undefined。</p>
<p>7、神马是 NaN，它的类型是神马？怎么测试一个值是否等于 NaN?</p>
<p>NaN 是 Not a Number 的缩写，JavaScript 的一种特殊数值，其类型是 Number，可以通过 isNaN(param)来判断一个值是否是 NaN：</p>
<p>console.log(isNaN(NaN)); //true<br>console.log(isNaN(23)); //false<br>console.log(isNaN(‘ds’)); //true<br>console.log(isNaN(‘32131sdasd’)); //true<br>console.log(NaN === NaN); //false<br>console.log(NaN === undefined); //false<br>console.log(undefined === undefined); //false<br>console.log(typeof NaN); //number<br>console.log(Object.prototype.toString.call(NaN)); //[object Number]<br>ES6 中，isNaN() 成为了 Number 的静态方法：Number.isNaN().</p>
<p>8、解释一下下面代码的输出</p>
<p>console.log(0.1 + 0.2);   //0.30000000000000004<br>console.log(0.1 + 0.2 == 0.3);  //false<br>JavaScript 中的 number 类型就是浮点型，JavaScript 中的浮点数采用IEEE-754 格式的规定，这是一种二进制表示法，可以精确地表示分数，比如1/2，1/8，1/1024，每个浮点数占64位。但是，二进制浮点数表示法并不能精确的表示类似0.1这样 的简单的数字，会有舍入误差。</p>
<p>由于采用二进制，JavaScript 也不能有限表示 1/10、1/2 等这样的分数。在二进制中，1/10(0.1)被表示为0.00110011001100110011…… 注意 0011 是无限重复的，这是舍入误差造成的，所以对于 0.1 + 0.2 这样的运算，操作数会先被转成二进制，然后再计算：</p>
<p>0.1 =&gt; 0.0001 1001 1001 1001…（无限循环）<br>0.2 =&gt; 0.0011 0011 0011 0011…（无限循环）<br>双精度浮点数的小数部分最多支持 52 位，所以两者相加之后得到这么一串 0.0100110011001100110011001100110011001100…因浮点数小数位的限制而截断的二进制数字，这时候，再把它转换为十进制，就成了 0.30000000000000004。</p>
<p>对于保证浮点数计算的正确性，有两种常见方式。</p>
<p>一是先升幂再降幂：</p>
<p>function add(num1, num2){<br>  let r1, r2, m;<br>  r1 = (‘’+num1).split(‘.’)[1].length;<br>  r2 = (‘’+num2).split(‘.’)[1].length;</p>
<p>  m = Math.pow(10,Math.max(r1,r2));<br>  return (num1 <em> m + num2 </em> m) / m;<br>}<br>console.log(add(0.1,0.2));   //0.3<br>console.log(add(0.15,0.2256)); //0.3756<br>二是是使用内置的 toPrecision() 和 toFixed() 方法，注意，方法的返回值字符串。</p>
<p>function add(x, y) {<br>    return x.toPrecision() + y.toPrecision()<br>}<br>console.log(add(0.1,0.2));  //“0.10.2”<br>9、实现函数 isInteger(x) 来判断 x 是否是整数</p>
<p>可以将 x 转换成10进制，判断和本身是不是相等即可：</p>
<p>function isInteger(x) {<br>    return parseInt(x, 10) === x;<br>}<br>ES6 对数值进行了扩展，提供了静态方法 isInteger() 来判断参数是否是整数：</p>
<p>Number.isInteger(25) // true<br>Number.isInteger(25.0) // true<br>Number.isInteger(25.1) // false<br>Number.isInteger(“15”) // false<br>Number.isInteger(true) // false<br>JavaScript能够准确表示的整数范围在 -2^53 到 2^53 之间（不含两个端点），超过这个范围，无法精确表示这个值。ES6 引入了Number.MAX_SAFE_INTEGER 和 Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限，并提供了 Number.isSafeInteger() 来判断整数是否是安全型整数。</p>
<p>10、在下面的代码中，数字 1-4 会以什么顺序输出？为什么会这样输出？</p>
<p>(function() {<br>    console.log(1);<br>    setTimeout(function(){console.log(2)}, 1000);<br>    setTimeout(function(){console.log(3)}, 0);<br>    console.log(4);<br>})();<br>这个就不多解释了，主要是 JavaScript 的定时机制和时间循环，不要忘了，JavaScript 是单线程的。详解可以参考 从setTimeout谈JavaScript运行机制。</p>
<p>11、写一个少于 80 字符的函数，判断一个字符串是不是回文字符串</p>
<p>function isPalindrome(str) {<br>    str = str.replace(/\W/g, ‘’).toLowerCase();<br>    return (str == str.split(‘’).reverse().join(‘’));<br>}<br>这个题我在 codewars 上碰到过，并收录了一些不错的解决方式，可以戳这里：Palindrome For Your Dome</p>
<p>12、写一个按照下面方式调用都能正常工作的 sum 方法</p>
<p>console.log(sum(2,3));   // Outputs 5<br>console.log(sum(2)(3));  // Outputs 5<br>针对这个题，可以判断参数个数来实现：</p>
<p>function sum() {<br>  var fir = arguments[0];<br>  if(arguments.length === 2) {<br>    return arguments[0] + arguments[1]<br>  } else {<br>    return function(sec) {<br>       return fir + sec;<br>    }<br>  }</p>
<p>}<br>13、根据下面的代码片段回答后面的问题</p>
<p>for (var i = 0; i &lt; 5; i++) {<br>  var btn = document.createElement(‘button’);<br>  btn.appendChild(document.createTextNode(‘Button ‘ + i));<br>  btn.addEventListener(‘click’, function(){ console.log(i); });<br>  document.body.appendChild(btn);<br>}<br>1、点击 Button 4，会在控制台输出什么？<br>2、给出一种符合预期的实现方式</p>
<p>1、点击5个按钮中的任意一个，都是输出5<br>2、参考 IIFE。</p>
<p>14、下面的代码会输出什么？为什么？</p>
<p>var arr1 = “john”.split(‘’); j o h n<br>var arr2 = arr1.reverse(); n h o j<br>var arr3 = “jones”.split(‘’); j o n e s<br>arr2.push(arr3);<br>console.log(“array 1: length=” + arr1.length + “ last=” + arr1.slice(-1));<br>console.log(“array 2: length=” + arr2.length + “ last=” + arr2.slice(-1));<br>会输出什么呢？你运行下就知道了，可能会在你的意料之外。</p>
<p>MDN 上对于 reverse() 的描述是酱紫的：</p>
<p>Description<br>The reverse method transposes the elements of the calling array object in place, mutating the array, and returning a reference to the array.<br>reverse() 会改变数组本身，并返回原数组的引用。</p>
<p>slice 的用法请参考：slice</p>
<p>15、下面的代码会输出什么？为什么？</p>
<p>console.log(1 +  “2” + “2”);<br>console.log(1 +  +”2” + “2”);<br>console.log(1 +  -“1” + “2”);<br>console.log(+”1” +  “1” + “2”);<br>console.log( “A” - “B” + “2”);<br>console.log( “A” - “B” + 2);<br>输出什么，自己去运行吧，需要注意三个点：</p>
<p>多个数字和数字字符串混合运算时，跟操作数的位置有关<br>console.log(2 + 1 + ‘3’); / /‘33’<br>console.log(‘3’ + 2 + 1); //‘321’<br>数字字符串之前存在数字中的正负号(+/-)时，会被转换成数字<br>console.log(typeof ‘3’);   // string<br>console.log(typeof +’3’);  //number<br>同样，可以在数字前添加 ‘’，将数字转为字符串</p>
<p>console.log(typeof 3);   // number<br>console.log(typeof (‘’+3));  //string<br>对于运算结果不能转换成数字的，将返回 NaN<br>console.log(‘a’ * ‘sd’);   //NaN<br>console.log(‘A’ - ‘B’);  // NaN<br>这张图是运算转换的规则</p>
<p>16、如果 list 很大，下面的这段递归代码会造成堆栈溢出。如果在不改变递归模式的前提下修善这段代码？</p>
<p>var list = readHugeList();</p>
<p>var nextListItem = function() {<br>    var item = list.pop();</p>
<pre><code>if (item) {
    // process the list item...
    nextListItem();
}
</code></pre><p>};<br>原文上的解决方式是加个定时器：</p>
<p>var list = readHugeList();</p>
<p>var nextListItem = function() {<br>    var item = list.pop();</p>
<pre><code>if (item) {
    // process the list item...
    setTimeout( nextListItem, 0);
}
</code></pre><p>};<br>解决方式的原理请参考第10题。</p>
<p>17、什么是闭包？举例说明</p>
<p>可以参考此篇：从作用域链谈闭包</p>
<p>18、下面的代码会输出什么？为啥？</p>
<p>for (var i = 0; i &lt; 5; i++) {<br>  setTimeout(function() { console.log(i); }, i * 1000 );<br>}<br>请往前面翻，参考第4题，解决方式已经在上面了</p>
<p>19、解释下列代码的输出</p>
<p>console.log(“0 || 1 = “+(0 || 1));<br>console.log(“1 || 2 = “+(1 || 2));<br>console.log(“0 &amp;&amp; 1 = “+(0 &amp;&amp; 1));<br>console.log(“1 &amp;&amp; 2 = “+(1 &amp;&amp; 2));<br>逻辑与和逻辑或运算符会返回一个值，并且二者都是短路运算符：</p>
<p>逻辑与返回第一个是 false 的操作数 或者 最后一个是 true的操作数<br>console.log(1 &amp;&amp; 2 &amp;&amp; 0);  //0<br>console.log(1 &amp;&amp; 0 &amp;&amp; 1);  //0<br>console.log(1 &amp;&amp; 2 &amp;&amp; 3);  //3<br>如果某个操作数为 false，则该操作数之后的操作数都不会被计算</p>
<p>逻辑或返回第一个是 true 的操作数 或者 最后一个是 false的操作数<br>console.log(1 || 2 || 0); //1<br>console.log(0 || 2 || 1); //2<br>console.log(0 || 0 || false); //false<br>如果某个操作数为 true，则该操作数之后的操作数都不会被计算</p>
<p>如果逻辑与和逻辑或作混合运算，则逻辑与的优先级高：</p>
<p>console.log(1 &amp;&amp; 2 || 0); //2<br>console.log(0 || 2 &amp;&amp; 1); //1<br>console.log(0 &amp;&amp; 2 || 1); //1<br>在 JavaScript，常见的 false 值：</p>
<p>0, ‘0’, +0, -0, false, ‘’,null,undefined,null,NaN<br>要注意空数组([])和空对象({}):</p>
<p>console.log([] == false) //true<br>console.log({} == false) //false<br>console.log(Boolean([])) //true<br>console.log(Boolean({})) //true<br>所以在 if 中，[] 和 {} 都表现为 true：</p>
<p>20、解释下面代码的输出</p>
<p>console.log(false == ‘0’)<br>console.log(false === ‘0’)<br>请参考前面第14题运算符转换规则的图。</p>
<p>21、解释下面代码的输出</p>
<p>var a={},<br>    b={key:’b’},<br>    c={key:’c’};</p>
<p>a[b]=123;<br>a[c]=456;</p>
<p>console.log(a[b]);<br>输出是 456，参考原文的解释：</p>
<p>The reason for this is as follows: When setting an object property, JavaScript will implicitly stringify the parameter value. In this case, since b and c are both objects, they will both be converted to “[object Object]”. As a result, a[b] anda[c] are both equivalent to a[“[object Object]”] and can be used interchangeably. Therefore, setting or referencing a[c] is precisely the same as setting or referencing a[b].<br>22、解释下面代码的输出</p>
<p>console.log((function f(n){return ((n &gt; 1) ? n * f(n-1) : n)})(10));<br>结果是10的阶乘。这是一个递归调用，为了简化，我初始化 n=5，则调用链和返回链如下：</p>
<p>23、解释下面代码的输出</p>
<p>(function(x) {<br>    return (function(y) {<br>        console.log(x);<br>    })(2)<br>})(1);<br>输出1，闭包能够访问外部作用域的变量或参数。</p>
<p>24、解释下面代码的输出，并修复存在的问题</p>
<p>var hero = {<br>    _name: ‘John Doe’,<br>    getSecretIdentity: function (){<br>        return this._name;<br>    }<br>};</p>
<p>var stoleSecretIdentity = hero.getSecretIdentity;</p>
<p>console.log(stoleSecretIdentity());<br>console.log(hero.getSecretIdentity());<br>将 getSecretIdentity 赋给 stoleSecretIdentity，等价于定义了 stoleSecretIdentity 函数：</p>
<p>var stoleSecretIdentity =  function (){<br>        return this._name;<br>}<br>stoleSecretIdentity 的上下文是全局环境，所以第一个输出 undefined。若要输出 John Doe，则要通过 call 、apply 和 bind 等方式改变 stoleSecretIdentity 的this 指向(hero)。</p>
<p>第二个是调用对象的方法，输出 John Doe。</p>
<p>25、给你一个 DOM 元素，创建一个能访问该元素所有子元素的函数，并且要将每个子元素传递给指定的回调函数。</p>
<p>函数接受两个参数：</p>
<p>DOM<br>指定的回调函数<br>原文利用 深度优先搜索(Depth-First-Search) 给了一个实现：</p>
<p>function Traverse(p_element,p_callback) {<br>   p_callback(p_element);<br>   var list = p_element.children;<br>   for (var i = 0; i &lt; list.length; i++) {<br>       Traverse(list[i],p_callback);  // recursive call<br>   }<br>}</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/06/03/我的第一篇篇文章/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">&lt;</strong>
      <div class="article-nav-title">
        
          我的第一篇篇文章
        
      </div>
    </a>
  
  
    <a href="/2015/04/09/一个过来人告诉你怎么学javascript/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">一个过来人告诉你怎么学javascript</div>
      <strong class="article-nav-caption">&gt;</strong>
    </a>
  
</nav>

  
</article>






</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2017 刘伟坤
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/smackgg/hexo-theme-smackdown" target="_blank">Smackdown</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/main.js"></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>